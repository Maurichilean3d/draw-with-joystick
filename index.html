// --- LÓGICA DE CONTROL AVANZADA (Smoothing + Gatillos) ---

let smoothX = W/2;
let smoothY = W/2;
const SMOOTH_FACTOR = 0.15; // Entre 0 y 1 (menor = más suave/lento)

function updateGamepad() {
    const gp = navigator.getGamepads()[0];
    if (!gp) return;

    // 1. MODIFICADOR DE PRECISIÓN (Gatillo Izquierdo - LT)
    // Si presionas LT, el cursor se mueve mucho más lento para detalles.
    const precisionMode = gp.buttons[6].value > 0.1;
    const speedMultiplier = precisionMode ? 2 : 10;

    // 2. LECTURA DE STICKS CON DEADZONE
    const rawLx = Math.abs(gp.axes[0]) > 0.1 ? gp.axes[0] : 0;
    const rawLy = Math.abs(gp.axes[1]) > 0.1 ? gp.axes[1] : 0;
    
    // Compensación por rotación del canvas
    const rad = -state.rotation * Math.PI / 180;
    const targetX = rawLx * Math.cos(rad) - rawLy * Math.sin(rad);
    const targetY = rawLx * Math.sin(rad) + rawLy * Math.cos(rad);

    // 3. IMPLEMENTACIÓN DEL SMOOTHING (Interpolación Lineal)
    // El cursor "persigue" al stick suavemente en lugar de saltar
    state.x += targetX * speedMultiplier;
    state.y += targetY * speedMultiplier;

    // Límites del lienzo
    state.x = Math.max(0, Math.min(W, state.x));
    state.y = Math.max(0, Math.min(H, state.y));

    // Suavizado visual del cursor
    smoothX += (state.x - smoothX) * SMOOTH_FACTOR;
    smoothY += (state.y - smoothY) * SMOOTH_FACTOR;

    // 4. PRESIÓN ANALÓGICA (Gatillo Derecho - RT)
    state.pressure = gp.buttons[7].value; // Valor entre 0.0 y 1.0

    if (state.pressure > 0.05) {
        if (!state.isDrawing) {
            state.isDrawing = true;
            state.lastX = smoothX;
            state.lastY = smoothY;
            saveHistory();
        }
        drawSmoothStroke();
    } else {
        state.isDrawing = false;
    }

    updateCursorUI(smoothX, smoothY);
}

function drawSmoothStroke() {
    ctx.beginPath();
    ctx.strokeStyle = state.color;
    // El grosor depende 100% de cuánto aprietas el gatillo RT
    ctx.lineWidth = state.size * (0.1 + state.pressure * 0.9);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.moveTo(state.lastX, state.lastY);
    ctx.lineTo(smoothX, smoothY);
    ctx.stroke();

    state.lastX = smoothX;
    state.lastY = smoothY;
}
